@startuml

package GraphingPackage {
  package GraphEncoding {
    class Canvas {
       {field} - PixelInstance : array of array of TPixel
       {field} - Height : integer
       {field} - Width : integer
      {method} + Canvas
      {method} + Canvas(integer, integer)
      {method} + Destroy
      {method} + integer GetCanvasHeight
      {method} + integer GetCanvasWidth
      {method} + Debug
    }

    class Pixel {
       {field} - PixelColor : TColor
       {field} - PixelLayer : integer
      {method} + Pixel
      {method} + Pixel(Color)
      {method} + Pixel(Color, integer)
      {method} + Destroy
      {method} + SetPixelColor(TColor) 
      {method} + SetLayer(integer) 
      {method} + TColor GetPixelColor() 
      {method} + integer GetPixelLayer()
      {method} + Debug
    }

    class Color {
       {field} - RedC : integer
       {field} - GreenC : integer
       {field} - BlueC : integer
      {method} + Color
      {method} + Color(integer, integer, integer)
      {method} + Debug
      {method} + SetColor(integer, integer, integer)
      {method} + SetRedC(integer)
      {method} + SetGreenC(integer)
      {method} + SetBlueC(integer)
      {method} + SetChannel(integer, integer, integer)
      {method} + integer GetRedC()
      {method} + integer GetGreenC()
      {method} + integer GetBlueC()
    }
  }

  package GraphPresets {
    class GraphScale {
       {field} - GSGraphBorder : TGraphBorder
       {field} - GSNumeric : array of TNumeric
       {field} - GSCoordinateAxes : array of TCoordinateAxis
       {field} - GSAxesTicMarks : array of TAxisTicMarks
      {method} + Create
      {method} + Create(real, real, real, real)
      {method} + Destroy
      {method} + WriteGraphScaleToCanvas(TCanvas)
    }

    class AxisTicMarks {
       {field} - ATMColor : TColor
       {field} - ATMQuantity : integer
       {field} - ATMWidth : integer
       {field} - ATMHeight : integer
      {method} + Create(integer, integer, integer, char)
      {method} + Destroy
      {method} + WriteATMToCanvas(TCanvas)
      {method} + integer GetATMQuantity
      {method} + integer GetATMWidth
      {method} + integer GetATMHeight
    }

    class CoordinateAxis {
       {field} - CAColor : TColor
       {field} - AxisMin : real
       {field} - AxisMax : real
       {field} - AxisWidth : integer
      {method} + Create(real, real, integer, char)
      {method} + Destroy
      {method} + real GetAxisMin()
      {method} + real GetAxisMax()
      {method} + WriteCoordinateAxisToCanvas(TCanvas)
    }

    class GraphBorder {
       {field} - BorderColor : TColor
       {field} - BorderWidth : integer
      {method} + GraphBorder(integer)
      {method} + Destroy
      {method} + WriteBorderToCanvas(TCanvas)
      {method} + integer GetBorder()
    }

    class Numeric {
       {field} - MonoSegment : array of array of integer
       {field} - Complement : array of boolean
       {field} - NumericLiteral : string
       {field} - NumericHeight : integer
       {field} - NumericWidth : integer
      {method} + Create(real, integer, integer)
      {method} + Destroy
      {method} + WriteNumericToCanvas(integer, integer, TCanvas)
      {method} + WriteMonoDigitToCanvas(integer, integer, integer, TCanvas)
      {method} + WriteComplementToCanvas(integer, integer, integer, TCanvas)
      {method} + Debug
    }
  }

  ' class relation {
  '   {method} + void write_rel_to_canvas(canvas *, GraphScale *, double(double), color*, double)
  '   {method} + int map_scale_to_canvas(canvas *, graph_scale *, axis, double)
  ' }

  ' class file_io {
  '   {method} + write_canvas_to_file(char *, canvas *)
  ' }
}

package FunctionCFG {
  package Lexer {
    class lexer {
       {field} + src : char *
       {field} + curr_index : int
       {field} + c : char
      {method} + lexer * init_lexer(char *)
      {method} + token_stack * lex_source(lexer *)
      {method} + token * lex_next_token(lexer *)
      {method} + token * lex_number(lexer *)
      {method} + token * lex_fn_or_var(lexer *)
      {method} + void lex_advance(lexer *)
      {method} + void lex_whitespace(lexer *)
      {method} + void free_lexer(lexer *)
    }
  }

  package Parser {
    class parser {
      {method} + ast * parse_expression(token_stack **)
      {method} + ast * parse_high_precedence_operator(token_stack **)
      {method} + ast * parse_term(token_stack **)
      {method} + ast * parse_factor(token_stack **)
      {method} + ast * binary_tree(ast *, ast *, ast *)
      {method} + ast * unary_tree(ast *, ast *)
    }

    class abstract_syntax_tree {
       {field} + value : token *
       {field} + children : abstract_syntax_tree **
       {field} + no_children : int
      {method} + ast * init_ast(char *, token_type)
      {method} + void ast_pretty_print(ast *)
      {method} + void ast_dump_debug(ast *)
      {method} + void free_ast(ast *)
    }
  }

  package Token {
    class token {
       {field} + t_literal : char *
       {field} + type : token_type
      {method} + token * init_token(char *, token_type)
      {method} + token ** init_token_list(void)
      {method} + token ** add_token_to_list(token **, token *, int)
      {method} + void token_dump_debug(token *)
      {method} + void free_token(token *)
      {method} + void free_token_list(token **)
    }

    class token_stack {
       {field} + current : token *
       {field} + prev : token_stack *
      {method} + token_stack * init_token_stack(token *)
      {method} + token_stack * push_token(token_stack *, token *)
      {method} + void token_stack_dump_debug(token_stack *)
      {method} + token_stack * reverse_stack(token_stack **)
      {method} + token_stack * pop_token(token_stack *)
    }

    enum token_type {
      TOKEN_VAR
      TOKEN_FILE_NAME
      TOKEN_NUMBER
      TOKEN_PLUS
      TOKEN_MINUS
      TOKEN_MULT
      TOKEN_DIV
      TOKEN_L_PAREN
      TOKEN_R_PAREN
      TOKEN_COMMA
      TOKEN_SUCH_THAT
      TOKEN_POWER
      TOKEN_SIN
      TOKEN_COS
      TOKEN_TAN
      TOKEN_ARC_SIN
      TOKEN_ARC_COS
      TOKEN_ARC_TAN
      TOKEN_LOG
      TOKEN_NEWLINE
      {method} + token_type_to_string(token_type)
    }
  }
}

' file_io related
' file_io --> lexer
' file_io --> graph_scale
' file_io --> canvas
' file_io --> parser
' file_io --> relation
' file_io --> user_out_file

' The arrows to color
Pixel        o--> Color
' graph_border o--> color

' The arrows relating to GraphEncoding
Canvas "1" o--> "*" Pixel

' The arrows relating to GraphingPresets
AxisTicMarks   "2" <-up-o "1" GraphScale
CoordinateAxis "2" <-up-o "1" GraphScale
GraphBorder        <-up-o     GraphScale
Numeric        "2" <-up-o "1" GraphScale

token       o--> token_type
token_stack o--> token

parser --> abstract_syntax_tree
parser --> token_stack

@enduml
